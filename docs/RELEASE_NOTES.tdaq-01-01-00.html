<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>RELEASE_NOTES</title>
  <style>
<!--
pre          {  }
-->
  </style>
</head>
<body>
<h4>Change Mechanism to Modify Attribute Values</h4>
<p>The mechanism used for user-defined modification of attributes values has
been changed.</p>
<p>Before a user-defined function was used, which was invoked when an attribute
of certain type was read from database. This was not flexible enough, since
parameters of the function were not defined by the user.</p>
<p>The substitution function was replaced by the substitution object. The user
defines a class as he likes and can define any parameters he needs. The only
rules he has to follow are:</p>
<ul>
  <li>class must to inherit from template class <i>::Configuration::AttributeConverter&lt;T&gt;</i>
    class, where template parameter T defines type of attributes which values
    need to be converted</li>
  <li>class must to implement virtual method <i>convert()</i>, which makes the
    real conversion of attribute values</li>
</ul>
<p>To register a converter object the user needs to create an object of his
class dynamically and pass pointer to the :<i>:Configuration::register_converter()</i>
method. The configuration destructor will destroy all registered converter
objects itself, so user must not do it himself and be careful with registering
of the same object more than once.</p>
<h5>Example</h5>
<p>Below there is example, which demonstrates how to write a simple class, which
will add user-defined prefix to values of attributes of string type.</p>
<blockquote>
  <pre>class AddPrefix : public ::Configuration::AttributeConverter&lt;std::string&gt; {
  private:
    std::string my_prefix;  <font color="#008000"><i>// keep parameters, provided by user (a single string in our case, but can be everything also)
</i></font>  public:
    AddPrefix (const std::string&amp; s) : my_prefix(s) {;} <font color="#008000"><i>// constructor to initialize user parameters
</i></font>    virtual void convert(std::string&amp; value, const ::Configuration&amp;, const ::ConfigObject&amp;, const std::string&amp;) {
      if(...) value = my_prefix + value;  <i><font color="#008000">// the code, which in some cases does the conversion
</font></i>    }
};</pre>
  <pre>...</pre>
  <pre>::Configuration db(...);
db.register_converter(new AddPrefix(&quot;test-&quot;)); <font color="#008000"><i>// registration of the conversion object</i></font></pre>
</blockquote>
<h4>Get Objects Referencing Given Object</h4>
<p>If there is a composite relationship between two classes (e.g. from class A
to B), then there is a fast way to get value of reverse relationship. E.g. if
class A has composite relationship X to class B, then from given object of class
B one can get information about objects of class A pointing to this object via
relationship X. In particular this can be useful to answer a question &quot;<i>Whom
this object belongs?</i>&quot;, e.g. if a crate contains list of modules, then
the operation to get crate of this module is straightforward.</p>
<p>The list of objects referencing given one can be obtained using two methods:</p>
<ul>
  <li>template&lt;class T, class V> bool ::Configuration::referenced_by(const T&amp; obj, const std::string&amp; relationship_name, std::vector&lt;const V*>&amp;
    objects, bool init = false)</li>
  <li>    bool referenced_by(const std::string&amp; relationship_name, const std::string&amp; class_name, std::vector&lt;ConfigObject>&amp; value)</li>
</ul>
<p>The first method should be used for objects of classes generated by the
genconfig. Below there is example to get crates referencing given module via
relationship &quot;<i>Modules</i>&quot;:</p>
<blockquote>
  <pre>::Configuration db(...);
::daq::core::Module m = db.get&lt;daq::core::Module&gt;(&quot;my module&quot;); <font color="#008000"><i>// get a module by any mean, e.g. by ID</i></font>
std::vector&lt;const daq::core::Crate *&gt; crates; <font color="#008000"><i>// the output vector</i></font>
db.referenced_by(m, &quot;Modules&quot;, crates); <i><font color="#008000">// get crates referencing given module</font></i>
std::cout &lt;&lt; &quot;Module " &lt;&lt; m &lt;&lt; " is referenced by " &lt;&lt; crates.size() &lt;&lt; " crates\n&quot;;
if(crates.size() > 0) { std::cout &lt;&lt; &quot;first crate is = " &lt;&lt; crates[0] &lt;&lt; std::endl; }</pre>
</blockquote>
<p>The second method should be used by developers, which use config abstract
database API directly.</p>
<h4>Bug Fixes</h4>
<ul>
  <li>Fix bug with access of inexistent objects by ID. In the past first attempt
    to read inexistent object returned <i>null</i>, that is correct. However by
    mistake such null pointer was registered in the cache of read objects of
    that class. Under certain circumstances (e.g. next access with the same ID)
    it resulted an error.</li>
  <li>Allow <i>::ConfigObject</i> point to null implementation object. It is
    required, when the <i>ConfigObject</i> is initialised by the <i>::Configuration::get(relationship,
    obj)</i><br>
    method and the relationship's value is set to <i>null</i>. Before in such
    case the method returned <i>false</i> and there was no way to differentiate
    between an error and the <i>null</i> value of relationship. Now the method's
    behaviour was corrected: it returns <i>false</i> only if implementation
    method fails; if the relationship is not set in the database, the method
    returns <i>true</i> and the <i>ConfigObject</i> points to <i>null</i>.</li>
</ul>
</body>
</html>
