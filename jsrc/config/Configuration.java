package config;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;



  /**
   *  The <b>Configuration</b> class provides interfaces to database data which are independent
   *  from the used database implementations. This includes access to the database objects
   *  by their identities or queries, creation of new databases, creation and destruction of
   *  database object and subscription on notification about database information changes.
   *  <p>
   *  It is assumed, to access the objects the methods generated by the genconfig utility
   *  are used. In this case all the information read from the database implementation is cached
   *  locally and updated via notification mechanism in case if it is modified.
   *  <p>
   *  The class is an entry point to the database information. It provides access
   *  to the database objects by name of the class and a query and optionally (for named objects)
   *  by object identities. A user should use this class to open/close database
   *  and to access objects via <i>get_</i> methods invoked with from the <i>*_Helper</i> classes
   *  generated by the genconfig utility.
   *
   *  Below there is brief description of basic methods. It is an error to call a method
   *  to get, create and destroy object(s) or set notification, when the database is not successfully loaded.
   *  A method throws {@link SystemException} exception in case of problems found
   *  by the implementation (can not connect with database server, can not load or save file, etc).
   *  A method throws {@link NotAllowedException} exception in case if user asks for an action which is
   *  not allowed (e.g. user has no rights to modify database, user has no permission to write to file, etc).
   *  If a method returns boolean value, the <b>true</b> means success and the <b>false</b> means
   *  that the method fails.
   *  <p>
   *  <b><u>Database Manipulation</u></b>
   *  <p>
   *  The database can be opened, closed and it's state can be checked by the following methods:
   *  <ul>
   *   <li><code>{@link #load(String db_name)}</code> - open database (by default, the database is opened by the constructor)
   *   <li><code>{@link #unload()}</code> - close database
   *   <li><code>{@link #loaded()}</code> - returns true, if a database is correctly loaded
   *  </ul>
   *  <p>
   *  The database can be modified by the following methods:
   *  <ul>
   *   <li><code>{@link #create(String server_name, String db_name, String[] includes)}</code> - create new database on given server and adds list of includes
   *   <li><code>{@link #add_include(String db_name, String include)}</code> - add include to given database
   *   <li><code>{@link #remove_include(String db_name, String include)}</code> - remove include from given database
   *   <li><code>{@link #commit()}</code> - saves changes made during transaction on disk
   *   <li><code>{@link #abort()}</code> - cancel changes made during transaction and re-read data from disk
   *  </ul>
   *  <p>
   *  <b><u>Objects Access, Creation and Destruction </u></b>
   *  <p>
   *  Such actions are provided via generated classes. For example for class xxx:
   *  <ul>
   *   <li><code>xxx_Helper.get(config.Configuration db, String id)</code> - get single object of class xxx with identity <i>id</i>
   *   <li><code>xxx_Helper.get(config.Configuration db, config.Query query)</code> - get objects of class xxx satisfying the query expression or get all objects of class xxx if query is empty
   *   <li><code>xxx_Helper.create(config.Configuration db, String dbname, String id)</code> - create object of given class with identity id in the database file with name <i>dbname</i>
   *   <li><code>xxx_Helper.create(config.Configuration db, config.DalObject at, String id)</code> - create object of given class with identity id in the database file where existing object <i>at</i> is stored
   *   <li><code>xxx.destroy(config.Configuration db)</code> - destroy given object of given class
   *  </ul>
   *  <p>
   *  <b><u>Notification</u></b>
   *  <p>
   *  To subscribe and unsubscribe on changes there are the following methods:
   *  <ul>
   *   <li><code>{@link #subscribe(Subscription)}</code> - subscribe on notification in case of database modification
   *   <li><code>{@link #unsubscribe(Subscription s)}</code> - remove above subscription
   *  </ul>
   *  The subscription object can be created by the {@link Subscription#Subscription(Callback, Object)} constructor.
   *  The subscription on class changes can be done by calling {@link Subscription#add(String class_name)} method.
   *  The subscription on individual object can be done by two ways:
   *  <ul>
   *   <li>using <code>{@link Subscription#add(String class_name, String object_id)}</code> method
   *   <li>using <code>{@link Subscription#add(DalObject obj)}</code> method suitable for an object of class generated by genconfig
   *  </ul>
   *
   *  @author  Igor Soloviev
   *  @since   online release 00-21-00
   */

public class Configuration
{
  static boolean m_debug = Boolean.getBoolean ( "tdaq.config.debug" );
  private Object lock = new Object();

  private ConfigurationImpl m_impl;
  private Hashtable<String, Hashtable<String, DalObject>> m_classes;
  private Vector<Subscription> m_subscriptions;
  private Hashtable<String,ArrayList<AttributeConverter>> m_attr_converters;
  private TreeMap<String,TreeSet<String>> m_superclasses;
  private TreeMap<String,TreeSet<String>> m_subclasses;
  private LinkedList<config.ConfigAction> m_config_actions;
  private TreeMap<String,class_t> p_direct_classes_desc_cache;
  private TreeMap<String,class_t> p_all_classes_desc_cache;


  public static boolean is_debug() { return m_debug; }
  
    /**
     *  Add config action.
     */

  public void add_config_action(ConfigAction obj) {
    synchronized(lock) {
      if(m_config_actions == null) m_config_actions = new LinkedList<config.ConfigAction>();
      m_config_actions.add(obj);
    }
  }


    /**
     *  The method reads hierarchy of superclasses from the implementation
     *  and constructs hierarchy of subclasses (to be used for cast).
     */

  private void get_inheritance_hierarchy() throws config.SystemException {

      // clean any previous data

    if(m_superclasses != null) { m_superclasses.clear(); }
    if(m_subclasses != null) { m_subclasses.clear(); }
    if(p_direct_classes_desc_cache != null) { p_direct_classes_desc_cache.clear(); }
    if(p_all_classes_desc_cache != null) { p_all_classes_desc_cache.clear(); }


      // nothing to do, if there is no implementation

    if(m_impl == null || loaded() == false) return;


      // read superclasses from implementation

    m_superclasses = m_impl.get_superclasses();
    
    if(m_superclasses == null) {
      System.err.println("ERROR: get_superclasses() returned (null).");
      return;
    }
    else if(m_debug == true) {
      System.out.println( "[DEBUG] ***** The superclasses hierarchy read from database schema *****" );
      System.out.println( m_superclasses.size() + " classes have superclasses:" );
    }


      // construct subclasses

    if(m_subclasses == null) {
      m_subclasses = new TreeMap<String,TreeSet<String>>();
    }

    for(Iterator<Map.Entry<String,TreeSet<String>>> i = m_superclasses.entrySet().iterator(); i.hasNext(); ) {
      Map.Entry<String,TreeSet<String>> e = i.next();
      String class_name = e.getKey();
      TreeSet<String> classes = e.getValue();

      StringBuffer debug_text = null;
      if(m_debug == true) {
        debug_text = new StringBuffer(" - class \'" + class_name + "\' has " + classes.size() + " superclass(es): ");
      }

      for(Iterator<String> j = classes.iterator(); j.hasNext();) {
        String name = j.next();

        if(m_debug == true) {
          debug_text.append('\'' + name + "\', ");
        }

        TreeSet<String> c = m_subclasses.get(name);
        if(c == null) {
          c = new TreeSet<String>();
          m_subclasses.put(name, c);
        }
        c.add(class_name);
      }
      
      if(m_debug == true) {
        System.out.println( debug_text.toString() );
      }
    }


      // if in DEBUG, then report constructed subclasses

    if(m_debug == true) {
      System.out.println( "[DEBUG] ***** The subclasses hierarchy built from above *****" );
      System.out.println( m_subclasses.size() + " classes have derived classes:" );

      for(Iterator<Map.Entry<String,TreeSet<String>>> i = m_subclasses.entrySet().iterator(); i.hasNext(); ) {
        Map.Entry<String,TreeSet<String>> e = i.next();
        String class_name = e.getKey();
        TreeSet<String> classes = e.getValue();

        StringBuffer debug_text = new StringBuffer(" - class \'" + class_name + "\' has " + classes.size() + " derived class(es): ");

        for(Iterator<String> j = classes.iterator(); j.hasNext();) {
          String name = j.next();
          debug_text.append('\'' + name + "\', ");
        }

        System.out.println( debug_text.toString() );
      }
    }
  }


    /**
     *  The method checks if cast from target class name to source class name is allowed.
     *
     *  @param target  name of cast target class (i.e. cast from)
     *  @param source  name of cast source class (i.e. cast to)
     */

  public boolean try_cast(String target, String source) {
    if(target.compareTo(source) == 0) {
      if(m_debug == true) {
        System.out.println( "[DEBUG]: cast from \'" + target + "\' to \'" + source + "\' is allowed (equal classes)" );
      }
      return true;
    }

    if(m_subclasses == null) {
      String text = "ERROR [config.try_cast(" + target + ", " + source + ")]: the inheritance hierarchy was not read";
      System.err.println(text);
      throw new RuntimeException(text);
    }

    TreeSet<String> sbc = m_subclasses.get(source);

    if(sbc == null) {
      if(m_debug == true) {
        System.out.println( "[DEBUG]: cast from \'" + target + "\' to \'" + source + "\' is not allowed (class has no superclasses)" );
      }
      return false;
    }

    if(sbc.contains(target) != false) {
      if(m_debug == true) {
        System.out.println( "[DEBUG]: cast from \'" + target + "\' to \'" + source + "\' is allowed (use inheritance)" );
      }
      return true;
    }

    if(m_debug == true) {
      System.out.println( "[DEBUG]: cast from \'" + target + "\' to \'" + source + "\' is not allowed (class \'" +
                          source + "\' has no \'" + target + "\' as a superclass)" );
    }

    return false;
  }



    /**
     *  Constructor to build the configuration object for given database name and implementation object.
     *  The constructor invokes {@link #load(String)} method with given database name.
     *
     *  @param db_name  name of the database (for the moment it is a name of the database server)
     *  @param impl     the implementation object
     */

  public Configuration(String db_name, ConfigurationImpl impl) throws SystemException {

      // implementation must always be provided

    if(impl == null) {
      String text = "ERROR [config.Configuration()]: the implemetation object is null";
      System.err.println(text);
      throw new config.SystemException(text);
    }

    m_impl = impl;
    m_impl.set_configuration(this);
    m_classes = new Hashtable<String, Hashtable<String, DalObject>>();
    m_subscriptions = new Vector<Subscription>();
    m_attr_converters = new Hashtable<String,ArrayList<AttributeConverter>>();
    load(db_name);
  }


    /**
     *  Constructor to build the configuration object using implementation plug-in.
     *  The constructor parses database specification in the format "$plugin:$param".
     *  The "$plugin" part of the spec is used to provide name of the implementation.
     *  The constructor searches the class in package "$plugin" with name created
     *  from "$plugin", where 1-st and 4-th characters are converted to uppercase
     *  and "uration" string is appended, e.g.: "oksconfig" plug-in name corresponds
     *  to the "oksconfig.OksConfiguration" implementation class.
     *  The "$param" is used as parameter of {@link #load(String)} method invoked on
     *  implementation object. The implementation class must be in the CLASSPATH.
     *
     *  The parameter used for database specification is the same, as used for C++
     *  config classes. If it is empty, then the constructor takes it's value from
     *  TDAQ_DB environment variable.
     *
     *  @param db_spec  database spec in the format described above
     */

  public Configuration(String db_spec) throws SystemException {

      // check TDAQ_DB variable if no spec was provided

    if(db_spec == null || db_spec.length() == 0) {
      try {
        db_spec = System.getenv("TDAQ_DB");
      }
      catch (final SecurityException ex) {
        throw new config.SystemException("System.getenv() failed", ex);
      }
    }

    if(db_spec == null || db_spec.length() == 0) {
      String text = "passed db_spec parameter is empty and TDAQ_DB is not set";
      System.err.println(text);
      throw new config.SystemException("ERROR [config.Configuration()]: " + text);
    }

    int idx = db_spec.indexOf(':');

    String impl_name = null;
    String impl_param = null;

    if(idx > 0) {
      impl_name = db_spec.substring(0, idx);
      impl_param = db_spec.substring(idx + 1);
    }
    else {
      impl_name = new String(db_spec);
    }


    String class_name = new String(impl_name + "." + Character.toUpperCase(impl_name.charAt(0)) + impl_name.charAt(1) + impl_name.charAt(2) + Character.toUpperCase(impl_name.charAt(3)) + impl_name.substring(4) + "uration");

    try {
      Class c = Class.forName(class_name);
      m_impl = (ConfigurationImpl)c.getDeclaredConstructor().newInstance();
      m_impl.set_configuration(this);
    }
    catch(final ClassNotFoundException ex) {
      throw new config.SystemException("implementation class " + class_name + " is not found", ex);
    }
    catch(final IllegalAccessException ex) {
      throw new config.SystemException("illegal access of implementation class " + class_name, ex);
    }
    catch(final InstantiationException ex) {
      throw new config.SystemException("cannot instantiate " + class_name, ex);
    }
    catch(final NoSuchMethodException ex) {
      throw new config.SystemException("no method to instantiate " + class_name, ex);
    }
    catch(final java.lang.reflect.InvocationTargetException ex) {
      throw new config.SystemException("invocation target exception during instantiation of " + class_name, ex);
    }

    m_classes = new Hashtable<String, Hashtable<String, DalObject>>();
    m_subscriptions = new Vector<Subscription>();
    m_attr_converters = new Hashtable<String,ArrayList<AttributeConverter>>();

    p_direct_classes_desc_cache = new TreeMap<String,class_t>();
    p_all_classes_desc_cache = new TreeMap<String,class_t>();

    if(impl_param != null) {
      load(impl_param);
    }
  }


  public void action_on_object_update(ConfigObject obj, String name) {
    synchronized(lock) {
      if(m_config_actions != null) {
        for(Iterator<config.ConfigAction> i = m_config_actions.iterator(); i.hasNext(); ) {
          i.next().update(obj, name);
        }
      }
    }
  }


    /**
     *  The method loads database with given name. The methods invokes method
     *  {@link ConfigurationImpl#open_db(String) open_db()} on implementation object.
     *
     *  @param db_name  name of the database (for the moment it is a name of the database server)
     */

  public synchronized void load(String db_name) throws SystemException {

        // call config actions if any

    synchronized(lock) {
      if(m_config_actions != null) {
        for(Iterator<config.ConfigAction> i = m_config_actions.iterator(); i.hasNext(); ) {
          i.next().load();
        }
      }
    }

    m_impl.open_db(db_name);
    get_inheritance_hierarchy();
  }

    /**
     *  The method closes a loaded database. Any used resources are released.
     *  <p>
     *  The client cache of objects is destroyed and any notification is stoped.
     *  No methods to get database data can be invoked in given configuration object
     *  after this method call until new database will be successfully  loaded by the
     *  {@link #load(String) load()} method.
     */

  public synchronized void unload() throws SystemException {

        // call config actions if any

    synchronized(lock) {
      if(m_config_actions != null) {
        for(Iterator<config.ConfigAction> i = m_config_actions.iterator(); i.hasNext(); ) {
          i.next().unload();
        }
      }
    }

    unsubscribe();
    m_classes.clear();
    m_impl.close_db();
    get_inheritance_hierarchy();
  }

    /** Returns <b>true</b> if there is a loaded database. */

  public boolean loaded() {
    return m_impl.loaded();
  }


      /** Get names of superclasses for each class **/

  public TreeMap<String,TreeSet<String> > superclasses() {
    return m_superclasses;
  }


      /** Get names of subclasses for each class **/

  public TreeMap<String,TreeSet<String> > subclasses() {
    return m_subclasses;
  }


    /**
     *  Create database.
     *
     *  The method creates database according to the name and list of others
     *  database files to be included.
     *  <p>
     *  If file already exists, the {@link AlreadyExistsException} is thrown.
     *
     *  @param server_name   server to be used to create new database file (to create several db files in a scope of single session put empty string on sequential calls)
     *  @param db_name       name of new database file (must be an absolute path to non-existing file)
     *  @param includes      optional list of others database files to be included
     *  
     *  @deprecated  see https://its.cern.ch/jira/browse/ADTCC-240 <br/>
     *    {will be removed in next version} <br/>
     *    use {@link #create(String db_name, String[] includes)} 
     */

  @Deprecated 
  public synchronized void create(String server_name, String db_name, String[] includes) throws SystemException, NotAllowedException, AlreadyExistsException {
    m_impl.create(server_name, db_name, includes);
    get_inheritance_hierarchy();
  }

	/**
     *  Create database.
	 *
	 *  The method creates database according to the name and list of others
     *  database files to be included.
	 *  
	 *  In case of rdb implementation, the server has to be connected using load() before this call.
	 *  
     *  <p>
     *  If file already exists, the {@link AlreadyExistsException} is thrown.
     *
     *  @param db_name       name of new database file (must be an absolute path to non-existing file)
     *  @param includes      optional list of others database files to be included
     */

  public synchronized void create(String db_name, String[] includes) throws SystemException, NotAllowedException, AlreadyExistsException {
    m_impl.create(db_name, includes);
    get_inheritance_hierarchy();
  }


    /**
     *  Add include file to existing database.
     *
     *  The method adds (and loads) existing include file to the database.
     *  The database <code>db_name</code> must be loaded before method call.
     *  The database <code>include</code> must exist before method call.
     *  <p>
     *  If database <code>db_name</code> is not loaded, the {@link NotFoundException} is thrown.
     *
     *  @param db_name       name of database file to be included
     *  @param include       file to be included
     */

  public synchronized void add_include(String db_name, String include) throws SystemException, NotFoundException, NotAllowedException {
    m_impl.add_include(db_name, include);
    get_inheritance_hierarchy();
  }


    /**
     *  Remove include file from existing database.
     *
     *  The method removes existing include file from the loaded database.
     *  <p>
     *  If database <code>db_name</code> is not loaded or there is no such include, the {@link NotFoundException} is thrown.
     *  If there are no permissions to modify the database, the {@link NotFoundException} is thrown.
     *
     *  @param db_name       name of database file from which the include to be removed
     *  @param include       file to be removed from includes
     */

  public synchronized void remove_include(String db_name, String include) throws SystemException, NotFoundException, NotAllowedException {
    m_impl.remove_include(db_name, include);
    get_inheritance_hierarchy();
  }


    /**
     *  Get include files.
     *
     *  The method returns list of includes for given database.
     *  <p>
     *  If database <code>db_name</code> is not loaded or there is no such include, the {@link NotFoundException} is thrown.
     *
     *  @param db_name       name of database
     */

  public synchronized String[] get_includes(String db_name) throws SystemException, NotFoundException {
    return m_impl.get_includes(db_name);
  }


    /**
     *  Get vector of updated files to be committed.
     *
     *  Return vector of strings containing names of uncommitted database files.
     */

  public synchronized String[] get_updated_dbs() throws SystemException, NotAllowedException {
    return m_impl.get_updated_dbs();
  }


    /**
     *  Set commit credentials.
     *
     *  The method sets credentials used by commit() method.
     *
     *  @param user       user name
     *  @param password   user password
     */

  public synchronized void set_commit_credentials(String user, String password) throws SystemException, NotAllowedException {
    m_impl.set_commit_credentials(user, password);
  }


    /**
     *  Commit database changes (compatibility).
     *
     *  The method commits the changes after a database was modified.
     *
     *  Return <b>true</b> if the database changes were successfully saved
     *  and <b>false</b> otherwise.
     */

  public boolean commit() throws SystemException, NotAllowedException {
    return commit(new String(""));
  }

  
    /**
     *  Commit database changes.
     *
     *  The method commits the changes after a database was modified.
     *
     *  @param log_message   log information
     *
     *  Return <b>true</b> if the database changes were successfully saved
     *  and <b>false</b> otherwise.
     */

  public synchronized boolean commit(String log_message) throws SystemException, NotAllowedException {
    boolean result = m_impl.commit(log_message);

    if(result == true) {
      Set<String> classes = m_classes.keySet();
      Iterator<String> i = classes.iterator();
      while (i.hasNext()) {
        String c = i.next();
        Hashtable<String, DalObject> objs = m_classes.get(c);
        Iterator<String> j = objs.keySet().iterator();
        while (j.hasNext()) {
          DalObject obj = objs.get(j.next());
          obj.config_object().m_is_updated = false;
          obj.config_object().m_is_created = false;
        }
      }
    }

    get_inheritance_hierarchy();
    return result;
  }

  
    /**
     *  Abort database changes.
     *
     *  The method rolls back any uncommitted changes.
     *
     *  Return <b>true</b> if the database changes were successfully rolled back
     *  and <b>false</b> otherwise.
     */

  public synchronized boolean abort() throws SystemException, NotAllowedException {
    boolean result = m_impl.abort();
    
    if(result == true) {
      HashSet<ConfigObject> updated = new HashSet<ConfigObject>();
      HashSet<ConfigObject> created = new HashSet<ConfigObject>();
      HashSet<ConfigObject> invalid = new HashSet<ConfigObject>();

      Set<String> classes = m_classes.keySet();
      Iterator<String> i = classes.iterator();

      while (i.hasNext()) {
        String c = i.next();
        Hashtable<String, DalObject> objs = m_classes.get(c);
        Iterator<String> j = objs.keySet().iterator();
        while (j.hasNext()) {
          DalObject obj = objs.get(j.next());
          ConfigObject o = obj.config_object();

          if(o.m_is_valid == false) {
            obj.unread(false);
            invalid.add(o);

            if(Configuration.m_debug) {
              System.out.println("abort(): invalid object \'" + o.UID() + '@' + o.class_name()  + "\' to be tested");
            }
          }
          else if(o.m_is_created) {
            obj.unread(false);
            created.add(o);

            if(Configuration.m_debug) {
              System.out.println("abort(): set created object \'" + o.UID() + '@' + o.class_name()  + "\' invalid");
            }
          }
          else if(o.m_is_updated) {
            obj.unread(false);
            updated.add(o);

            if(Configuration.m_debug) {
              System.out.println("abort(): unread updated object \'" + o.UID() + '@' + o.class_name()  + '\'');
            }
          }
        }
      }

        // process updated config objects
      {
        Iterator<ConfigObject> j = updated.iterator();

        while (j.hasNext()) {
          ConfigObject o = j.next();
          o.clean();
          o.m_is_updated = false;
  
          if(Configuration.m_debug) {
            System.out.println("abort(): unread updated config object \'" + o.UID() + '@' + o.class_name()  + '\'');
          }
        }
      }

        // process created config objects
      {
        Iterator<ConfigObject> j = created.iterator();

        while (j.hasNext()) {
          ConfigObject o = j.next();
          o.clean();
          o.m_is_valid = o.m_is_created = o.m_is_updated = false;

          if(Configuration.m_debug) {
            System.out.println("abort(): set created config object \'" + o.UID() + '@' + o.class_name()  + "\' invalid");
          }
        }
      }


        // process invalid config objects
      {
        Iterator<ConfigObject> j = invalid.iterator();
  
        while (j.hasNext()) {
          ConfigObject o = j.next();

          try {
            if(m_impl.get(o.class_name(), o.UID()) != null) {
              o.clean(); // to re-read DAL objects
              o.m_is_valid = true;
              o.m_is_created = false;
              o.m_is_updated = false;
 
              if(Configuration.m_debug) {
                System.out.println("abort(): config object \'" + o.UID() + '@' + o.class_name()  + "\' is valid");
              }
            }
          }
          catch(final SystemException ex) {
            if(Configuration.m_debug) {
              System.out.println("abort(): object \'" + o.UID() + '@' + o.class_name()  + "\' remains invalid: " + ex.getMessage());
            }
          }
          catch(final NotFoundException ex) {
            if(Configuration.m_debug) {
              System.out.println("abort(): object \'" + o.UID() + '@' + o.class_name()  + "\' remains invalid: " + ex.getMessage());
            }
          }

        }
      }

    }

    get_inheritance_hierarchy();

    return result;
  }

    /**
     *  The method returns object by it's class name and identity.
     *  In case if no such object is found, the method throws
     *  exception {@link NotFoundException}.
     *  <p>
     *  The method is used by the code generated by the genconfig.
     *  There is no a reason to use this method directly, if a package
     *  generated by the genconfig is used to access database information.
     */

  public synchronized ConfigObject get_object(String class_name, String object_id) throws SystemException, NotFoundException {
    return m_impl.get(class_name, object_id);
  }

    /**
     *  The method returns array of objects of given class which satisfies to the query expression.
     *  If the query is empty, all objects of given class and it's subclasses are returned.
     *  In case if no such class is found or query has bad syntax, the method throws
     *  exception {@link NotFoundException}.
     *  <p>
     *  The method is used by the code generated by the genconfig.
     *  There is no a reason to use this method directly, if a package
     *  generated by the genconfig is used to access database information.
     */

  public synchronized ConfigObject[] get_objects(String class_name, Query query) throws SystemException, NotFoundException {
    return m_impl.get(class_name, query);
  }

    /**
     *  The method returns array of objects which are in the path starting from source object
     *  matching to the path query pattern. In case of problems, the method throws
     *  exceptions: {@link NotFoundException}, {@link SystemException}.
     *  <p>
     */

  public synchronized ConfigObject[] get_path(ConfigObject from, Query query) throws SystemException, NotFoundException {
    return m_impl.get(from, query);
  }


    /**
     *  The method returns from cache an object of class generated by the genconfig
     *  or <code>null</code> if no such object found in cache.
     *  <p>
     *  The method is used by the code generated by the genconfig.
     *  There is no a reason to use this method directly, if a package
     *  generated by the genconfig is used to access database information.
     */

  public Object get(String class_name, ConfigObject obj) {
    return get(class_name, obj.UID());
  }


    /**
     *  The method returns from cache an object of class generated by the genconfig
     *  or <code>null</code> if no such object found in cache.
     *  <p>
     *  The method is used by the code generated by the genconfig.
     *  There is no a reason to use this method directly, if a package
     *  generated by the genconfig is used to access database information.
     */

  public synchronized DalObject get(String class_name, String object_id) {
    Hashtable<String, DalObject> cache = m_classes.get(class_name);
    if(cache == null) {
      return null;
    }
    else {
      return cache.get(object_id);
    }
  }


    /**
     *  The method adds to cache an object of class generated by the genconfig.
     *  <p>
     *  The method is used by the code generated by the genconfig.
     *  There is no a reason to use this method directly, if a package
     *  generated by the genconfig is used to access database information.
     */

  public synchronized void add(String class_name, String id, DalObject obj) {
    Hashtable<String, DalObject> cache = m_classes.get(class_name);
    if(cache == null) {
      cache = new Hashtable<String, DalObject>();
      m_classes.put(class_name, cache);
    }
    cache.put(id, obj);
  }


    /**
     *  The method creates new object providing database file name, class name and object identity.
     *
     *  @param db          database file name
     *  @param class_name  class name
     *  @param object_id   object identity
     */

  public synchronized ConfigObject create(String db, String class_name, String object_id) throws SystemException, NotFoundException, NotAllowedException {
    ConfigObject o = m_impl.create(db, null, class_name, object_id);
    o.m_is_created = true;
    return o;
  }


    /**
     *  The method creates new object providing class name and object identity.
     *  The object is created in the same database file, as existing object.
     *
     *  @param at          create new object at the same database file where \b 'at' object is located
     *  @param class_name  class name
     *  @param object_id   object identity
     */

  public synchronized ConfigObject create(ConfigObject at, String class_name, String object_id) throws SystemException, NotFoundException, NotAllowedException {
    ConfigObject o = m_impl.create(null, at, class_name, object_id);
    o.m_is_created = true;
    return o;
  }


    // Helper method for destroy(ConfigObject object)

  private void remove_invalid_dal_object(String class_name, String id) {
    Hashtable<String, DalObject> cache = m_classes.get(class_name);

    if(cache != null) {
      DalObject obj = cache.remove(id);
      if(obj != null && obj.config_object().m_is_valid == true) {
        obj.config_object().clean();
        obj.config_object().m_is_valid = false;
      }
    }
  }

    /**
     *  The method destroys given object.
     *
     *  @param object   the object to be destroyed
     */

  public synchronized void destroy(ConfigObject object) throws SystemException, NotFoundException, NotAllowedException {
    m_impl.destroy(object);

    object.clean();
    object.m_is_valid = false;


      // remove all DAL objects from this class and subclasses
    
    remove_invalid_dal_object(object.class_name(), object.UID());
    
    TreeSet<String> superclasses = m_superclasses.get(object.class_name());

    if(superclasses != null) {
      Iterator<String> i = superclasses.iterator();
      while(i.hasNext()) {
        remove_invalid_dal_object(i.next(), object.UID());
      }
    }
  }


  /**
   *  The method moves existing object to a database.
   *
   *  @param object      the object to be moved
   *  @param at          database file name
   */

  public synchronized void move(ConfigObject object, String at) throws SystemException, NotFoundException, NotAllowedException {
    m_impl.move(object, at);
  }


    /** Reset subscriptions in case of a modification */

  private synchronized void reset_subscription() throws SystemException {
    if(m_subscriptions.size() == 0) {
      m_impl.unsubscribe();
    }
    else if(m_subscriptions.size() == 1) {
      Subscription s = m_subscriptions.firstElement();
      m_impl.subscribe(s.m_class_subscriptions, s.m_obj_subscriptions, this);
    }
    else {

      Iterator<Subscription> icb = m_subscriptions.iterator();  // callback iterator

        // check if need to subscribe on all changes
 
      for(int i = 0; i < m_subscriptions.size(); ++i) {
        Subscription s = icb.next();
        if( (s.m_obj_subscriptions == null || s.m_obj_subscriptions.size() == 0) && (s.m_class_subscriptions == null || s.m_class_subscriptions.size() == 0)) {
          m_impl.subscribe(null, null, this);
          break;
        }
      }


        // build parameters taking into account all subscriptions

      TreeSet<String> classes = new TreeSet<String>();
      Hashtable<String,TreeSet<String>> objects = new Hashtable<String,TreeSet<String>>();


      icb = m_subscriptions.iterator();  // reset iterator

      while(icb.hasNext()) {
        Subscription s = icb.next();
	
        if(s.m_class_subscriptions != null) {
          for(Iterator<String> icl = s.m_class_subscriptions.iterator(); icl.hasNext(); ) {
            classes.add(icl.next());
          }
        }
      }


      icb = m_subscriptions.iterator();

      while(icb.hasNext()) {
        Subscription s = icb.next();

        if(s.m_obj_subscriptions != null) {
          for(Enumeration<String> keys = s.m_obj_subscriptions.keys(); keys.hasMoreElements() ;) {
            String class_name = keys.nextElement();
	    
            if(classes.contains(class_name) == false) {
              TreeSet<String> objs = objects.get(class_name);

              if(objs == null) {
                objs = new TreeSet<String>();
                objects.put(class_name, objs);
              }

              TreeSet<String> class_objs = s.m_obj_subscriptions.get(class_name);
	      
              for(Iterator<String> iobjs = class_objs.iterator(); iobjs.hasNext(); ) {
                objs.add(iobjs.next());
              }
            }
          }
        }
      }

      m_impl.subscribe(classes, objects, this);
    }
  }

    /**
     *  The method subscribes on notification in case of database changes in accordance with
     *  the subscription criteria. In case of system errors caught by the implementation,
     *  the method throws exception {@link SystemException}.
     *  @param s subscription criteria with user callback
     */

  public synchronized void subscribe(Subscription s) throws SystemException {
    m_subscriptions.add(s);
    reset_subscription();
  }


    /**
     *  The method removes previously registered subscription.
     *  In case of system errors caught by the implementation, the method throws exception {@link SystemException}.
     *  If no such subscription was registered, the method prints out warning message.
     *  @param s the subscription object used as parameter of the {@link #subscribe(Subscription) subscribe()} method
     */

  public synchronized void unsubscribe(Subscription s) throws SystemException {
    if(m_subscriptions.remove(s) == true) {
      reset_subscription();
    }
    else {
      System.err.println("WARNING [config.unsubscribe()]: no such subscription has been found");
    }
  }

    /**
     *  The method removes all previously registered subscriptions.
     *  In case of system errors caught by the implementation, the method throws exception {@link SystemException}.
     */

  public synchronized void unsubscribe() throws SystemException {
    if(m_subscriptions.size() > 0) {
      m_subscriptions.clear();
      m_impl.unsubscribe();
    }
  }


  private static void add_change(Hashtable<String,Vector<String>> table, String class_name, String object_id) {
    Vector<String> v = table.get(class_name);

    if(v == null) {
      v = new Vector<String>();
      table.put(class_name, v);
    }

    v.add(object_id);
  }


  private static void check_change(String class_name, String[] objs, Subscription s, Hashtable<String,Vector<String>> table) {
    if(objs != null) {
      for(int i = 0; i < objs.length; ++i) {
        if((s.m_class_subscriptions != null) && (s.m_class_subscriptions.contains(class_name) == true)) {
          add_change(table, class_name, objs[i]);
          if(Configuration.m_debug) {
            System.out.println("   # add object \'" + objs[i] + "@" + class_name + "\' (class subscription)");
          }
        }
        else if(s.m_obj_subscriptions != null) {
          TreeSet<String> s1 = s.m_obj_subscriptions.get(class_name);

          if(s1 != null && s1.contains(objs[i])) {
            add_change(table, class_name, objs[i]);
            if(Configuration.m_debug) {
              System.out.println("   # add object \'" + objs[i] + "@" + class_name + "\' (object subscription)");
            }
          }
        }
        else if(Configuration.m_debug) {
          System.out.println("   # skip object \'" + objs[i] + "@" + class_name + "\' (no subscription found)");
        }
      }
    }
  }

  private void update_changed_objects(String class_name, String[] changed_objects) {
    if(Configuration.m_debug) {
      System.out.println(" * check " + changed_objects.length + " modified objects in class \"" + class_name + "\"");
    }

    Hashtable<String, DalObject> cache = m_classes.get(class_name);

    if(cache != null) {
      for(int j = 0; j < changed_objects.length; ++j) {
        try {
          DalObject obj = cache.get(changed_objects[j]);
          if(obj != null) {
            if(Configuration.m_debug) {
              System.out.println("  * update object \"" + obj.UID() + "\" (found in cache)");
            }
            obj.update();
          }
          else if(Configuration.m_debug) {
            System.out.println("  * skip object \"" + changed_objects[j] + "\" (not found in cache)");
          }
        }
        catch(final config.ConfigException ex) {
        	ers.Logger.error(new SystemException("failed to update modified object \'" + changed_objects[j] + '@' + class_name + "\')", ex));
        }
      }
    }
    else if(Configuration.m_debug){
      System.out.println("  * cache is empty");
    }
  }

  /**
   *  The method marks DAL objects as unread.
   *  If the parameter is <b>false</b>, then the implementation objects remains untaught (that is useful for parameter substitution).
   *  Otherwise the implementation objects are cleared and the objects will be re-read from implementation on next access.
   *
   *  @param clear_implementation_object      if true, clear all implementation objects
   */

  public synchronized void unread_all_objects(boolean clear_implementation_object) {
    if(Configuration.m_debug) {
      System.out.println("DEBUG [unread_all_objects(clear implementation object: " + clear_implementation_object + ")]:");
    }
    Set<String> classes = m_classes.keySet();
    Iterator<String> i = classes.iterator();
    while (i.hasNext()) {
      String c = i.next();
      if(Configuration.m_debug) {
        System.out.println(" * unread objects of class \"" + c + "\"");
      }
      Hashtable<String, DalObject> objs = m_classes.get(c);
      Set<String> objs_set = objs.keySet();
      Iterator<String> j = objs_set.iterator();
      while (j.hasNext()) {
        String o = j.next();
        DalObject obj = objs.get(o);
        if(Configuration.m_debug) {
          System.out.println("  - unread object \"" + o + "\"");
        }
        obj.unread(clear_implementation_object);
      }
    }
  }
  
  private void remove_deleted_objects(String class_name, String[] deleted_objects, String[] created_objects) {
    if(Configuration.m_debug)
      System.out.println(" * check " + deleted_objects.length + " removed objects in class \"" + class_name + "\"");

    Hashtable<String, DalObject> cache = m_classes.get(class_name);

    if(cache != null) {
      Set<String> created_set = (created_objects != null) ? new HashSet<>(Arrays.asList(created_objects)) : null;

      for(int j = 0; j < deleted_objects.length; ++j) {
        if (created_set != null && created_set.contains(deleted_objects[j])) {
          DalObject obj = cache.get(deleted_objects[j]);

          if (obj != null) {
            obj.unread(false);
            try
              {
                obj.init_config_params(this, get_object(class_name, deleted_objects[j]), deleted_objects[j]);

                if(Configuration.m_debug)
                  System.out.println("  * reset recreated object \"" + obj.UID() + "\" in cache");
              }
            catch (SystemException | NotFoundException ex)
              {
                ers.Logger.error(ex);
              }
          }
          else if(Configuration.m_debug) {
            System.out.println("  * skip recreated object \"" + deleted_objects[j] + "\" (not found in cache)");
          }
        }
        else {
          DalObject obj = cache.remove(deleted_objects[j]);
          
          if (obj != null) {
            obj.config_object().clean();
            obj.config_object().m_is_valid = false;

            if(Configuration.m_debug)
              System.out.println("  * remove deleted object \"" + obj.UID() + "\" from cache");
          }
          else if(Configuration.m_debug) {
            System.out.println("  * skip deleted object \"" + deleted_objects[j] + "\" (not found in cache)");
          }
        }
      }
    }
    else if(Configuration.m_debug) {
      System.out.println("  * cache is empty");
    }
  }

    /**
     *  The method notifies the configuration object about changes.
     *  It is used by the implementations and should not be used directly
     *  by the user.
     */

  synchronized void notify(Change[] changes) {

    if(Configuration.m_debug) {
      System.out.println("DEBUG: enter Configuration.notify()\n*** got notification on changes ***");
      Change.print(changes, "  ");
      System.out.println("***********************************\n");
    }


    if(changes != null) {

        // call config actions if any

      synchronized(lock) {
        if(m_config_actions != null) {
          for(Iterator<config.ConfigAction> i = m_config_actions.iterator(); i.hasNext(); ) {
              i.next().notify(changes);
          }
        }
      }


        // update cache

      if(Configuration.m_debug) {
        System.out.println("*** update configuration cache ***");
      }

      for(int i = 0; i < changes.length; ++i) {
        Change change = changes[i];
        String[] changed_objects = change.get_changed_objects();
        String[] deleted_objects = change.get_deleted_objects();

          // update objects in cache

        if(changed_objects != null) {
          update_changed_objects(change.get_class_name(), changed_objects);
        }

          // remove from cache deleted objects

        if(deleted_objects != null) {
          remove_deleted_objects(change.get_class_name(), deleted_objects, change.get_created_objects());
	      }
      }

      if(Configuration.m_debug) {
        System.out.println("**********************************\n");
      }

        // notify subscribers

      if(Configuration.m_debug) {
        System.out.println("*** check " + m_subscriptions.size() + " user subscription(s) ***");
      }

      if(m_subscriptions.size() == 1) {
        Subscription s = m_subscriptions.firstElement();

        if(Configuration.m_debug) {
          System.out.println(" * invoke");
          s.print("   ");
          System.out.println("   with changes");
          Change.print(changes, "   ");
        }

        s.m_cb.process_changes(changes, s.m_parameter);

      }
      else if(m_subscriptions.size() > 1) {
        Hashtable<String,Vector<String>> created = new Hashtable<String,Vector<String>>();
        Hashtable<String,Vector<String>> changed = new Hashtable<String,Vector<String>>();
        Hashtable<String,Vector<String>> removed = new Hashtable<String,Vector<String>>();

        for(Iterator<Subscription> icb = m_subscriptions.iterator(); icb.hasNext(); ) {
          Subscription s = icb.next();

          if(Configuration.m_debug) {
            System.out.println(" * check subscription ");
            s.print("   ");
          }

          if((s.m_obj_subscriptions == null || s.m_obj_subscriptions.size() == 0) && (s.m_class_subscriptions == null || s.m_class_subscriptions.size() == 0)) {
            if(Configuration.m_debug) {
              System.out.println(" * invoke with changes");
              Change.print(changes, "   ");
            }

            s.m_cb.process_changes(changes, s.m_parameter);
          }
          else {
            if(Configuration.m_debug) {
              System.out.println(" * test database changes");
            }

            created.clear();
            changed.clear();
            removed.clear();

            for(int i = 0; i < changes.length; ++i) {
              check_change(changes[i].get_class_name(), changes[i].get_created_objects(), s, created);
              check_change(changes[i].get_class_name(), changes[i].get_changed_objects(), s, changed);
              check_change(changes[i].get_class_name(), changes[i].get_deleted_objects(), s, removed);
            }

              // names of changed classes relevant to the subscription s

            TreeSet<String> changed_classes_names = new TreeSet<String>();

            for(Enumeration<String> keys = created.keys(); keys.hasMoreElements() ;) {
              changed_classes_names.add(keys.nextElement());
            }

            for(Enumeration<String> keys = changed.keys(); keys.hasMoreElements() ;) {
              changed_classes_names.add(keys.nextElement());
            }

            for(Enumeration<String> keys = removed.keys(); keys.hasMoreElements() ;) {
              changed_classes_names.add(keys.nextElement());
            }

            if(changed_classes_names.size() > 0) {
              Change[] s_changes = new Change[changed_classes_names.size()];

              int j = 0;

              for(Iterator<String> icn = changed_classes_names.iterator(); icn.hasNext(); j++) {
                String changed_class_name = icn.next();
                s_changes[j] = new Change(
                  changed_class_name,
                  created.get(changed_class_name),
                  changed.get(changed_class_name),
                  removed.get(changed_class_name)
                );
              }

              if(Configuration.m_debug) {
                System.out.println(" * invoke with changes");
                Change.print(s_changes, "   ");
              }

              s.m_cb.process_changes(s_changes, s.m_parameter);
            }
          }
        }
      }

      if(Configuration.m_debug) {
        System.out.println("**********************************\n");
      }
    }
  }


    /**
     * The method registers new attribute converter object.
     * 
     * @param ac
     *          attribute converter object
     */

  public synchronized void register_converter(AttributeConverter ac) {
    ArrayList<AttributeConverter> c = m_attr_converters.get(ac.get_class().getName());
    if(c == null) {
      c = new ArrayList<AttributeConverter>();
      m_attr_converters.put(ac.get_class().getName(), c);
    }
    c.add(ac);
  }


    /**
     * The method to invoke attribute value converters registered for given
     * attribute type.
     * 
     * @param value
     *          the value to be converted; the method modifies this value, if a
     *          conversion is required
     * @param obj
     *          the converted object
     * @param attr_name
     *          name of the attribute which value to be converted
     */

  public Object convert(Object value, ConfigObject obj, String attr_name) throws config.GenericException, config.NotFoundException, config.NotValidException, config.SystemException {
    ArrayList<AttributeConverter> c = m_attr_converters.get(value.getClass().getName());
    if(c != null) {
      for(Iterator<AttributeConverter> i = c.iterator(); i.hasNext(); ) {
        value = i.next().convert(value, this, obj, attr_name);
      }
    }
    return value;
  }


	/**
	 * The method provides access to description of class. The method throws
	 * 
	 * @param class_name
	 *            name of the class
	 * @param direct_only
	 *            if true is set explicitly, return descriptions of direct
	 *            attributes, relationships, super- and subclasses; by default
	 *            return all descriptions taking into account inheritance
	 * @return Return pointer to class description object.
	 * @throws NotFoundException
	 *             exception if there is no class with such name
	 * @throws SystemException
	 *             in case of a problem
	 */

  public synchronized class_t get_class_info(String class_name, boolean direct_only) throws SystemException, NotFoundException
    {
      TreeMap<String,class_t> d_cache = (direct_only ? p_direct_classes_desc_cache : p_all_classes_desc_cache);

      class_t c = d_cache.get(class_name);

      if(c == null)
        {
          c = m_impl.get(class_name, direct_only);
          d_cache.put(class_name, c);
        }

      return c;
    }


	/**
	 * The method returns new config versions created on remote origin after current
	 * HEAD version, or externally modified files
	 * 
	 * @return Return vector of versions.
	 * @throws SystemException
	 *             in case of a problem
	 */

  public synchronized Version[]
  get_changes() throws SystemException
  {
	  return m_impl.get_changes();
  }


	/**
	 * The method returns historical repository versions in a query interval defined
	 * by user.
	 *
	 * The date/time format has to be either a date in format "yyyy-mm-dd" or
	 * date-and-time in format "yyyy-mm-dd hh:mm:ss" (UTC).
	 *
	 * @param since
	 *            limit the versions committed on-or-after the specified hash key,
	 *            tag or date/time; if empty, start from earliest available
	 * @param until
	 *            limit the versions committed on-or-before the specified hash key,
	 *            tag or date/time; if empty, retrieve all versions until
	 *            "origin/master"
	 * @param type
	 *            define query type
	 * @param skip_irrelevant
	 *            if true, ignore changes not affecting loaded configuration
	 * 
	 * @return repository versions satisfying query
	 * @throw SystemException din case of an error
	 */

  public synchronized Version[]
  get_versions(String since, String until, Version.QueryType type, boolean skip_irrelevant) throws SystemException
  {
	  return m_impl.get_versions(since, until, type, skip_irrelevant);
  }


}
